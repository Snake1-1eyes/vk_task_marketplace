// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Snake1-1eyes/vk_task_marketplace/internal/auth.UseCase -o usecase_mock.go -n UseCaseMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Snake1-1eyes/vk_task_marketplace/internal/entity"
	"github.com/gojuno/minimock/v3"
)

// UseCaseMock implements mm_auth.UseCase
type UseCaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcLogin          func(ctx context.Context, username string, password string) (s1 string, up1 *entity.UserResponse, err error)
	funcLoginOrigin    string
	inspectFuncLogin   func(ctx context.Context, username string, password string)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mUseCaseMockLogin

	funcRegister          func(ctx context.Context, username string, password string) (up1 *entity.UserResponse, err error)
	funcRegisterOrigin    string
	inspectFuncRegister   func(ctx context.Context, username string, password string)
	afterRegisterCounter  uint64
	beforeRegisterCounter uint64
	RegisterMock          mUseCaseMockRegister

	funcVerifyToken          func(ctx context.Context, token string) (u1 uint64, err error)
	funcVerifyTokenOrigin    string
	inspectFuncVerifyToken   func(ctx context.Context, token string)
	afterVerifyTokenCounter  uint64
	beforeVerifyTokenCounter uint64
	VerifyTokenMock          mUseCaseMockVerifyToken
}

// NewUseCaseMock returns a mock for mm_auth.UseCase
func NewUseCaseMock(t minimock.Tester) *UseCaseMock {
	m := &UseCaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.LoginMock = mUseCaseMockLogin{mock: m}
	m.LoginMock.callArgs = []*UseCaseMockLoginParams{}

	m.RegisterMock = mUseCaseMockRegister{mock: m}
	m.RegisterMock.callArgs = []*UseCaseMockRegisterParams{}

	m.VerifyTokenMock = mUseCaseMockVerifyToken{mock: m}
	m.VerifyTokenMock.callArgs = []*UseCaseMockVerifyTokenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUseCaseMockLogin struct {
	optional           bool
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockLoginExpectation
	expectations       []*UseCaseMockLoginExpectation

	callArgs []*UseCaseMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UseCaseMockLoginExpectation specifies expectation struct of the UseCase.Login
type UseCaseMockLoginExpectation struct {
	mock               *UseCaseMock
	params             *UseCaseMockLoginParams
	paramPtrs          *UseCaseMockLoginParamPtrs
	expectationOrigins UseCaseMockLoginExpectationOrigins
	results            *UseCaseMockLoginResults
	returnOrigin       string
	Counter            uint64
}

// UseCaseMockLoginParams contains parameters of the UseCase.Login
type UseCaseMockLoginParams struct {
	ctx      context.Context
	username string
	password string
}

// UseCaseMockLoginParamPtrs contains pointers to parameters of the UseCase.Login
type UseCaseMockLoginParamPtrs struct {
	ctx      *context.Context
	username *string
	password *string
}

// UseCaseMockLoginResults contains results of the UseCase.Login
type UseCaseMockLoginResults struct {
	s1  string
	up1 *entity.UserResponse
	err error
}

// UseCaseMockLoginOrigins contains origins of expectations of the UseCase.Login
type UseCaseMockLoginExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mUseCaseMockLogin) Optional() *mUseCaseMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for UseCase.Login
func (mmLogin *mUseCaseMockLogin) Expect(ctx context.Context, username string, password string) *mUseCaseMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UseCaseMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UseCaseMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("UseCaseMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &UseCaseMockLoginParams{ctx, username, password}
	mmLogin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for UseCase.Login
func (mmLogin *mUseCaseMockLogin) ExpectCtxParam1(ctx context.Context) *mUseCaseMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UseCaseMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UseCaseMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("UseCaseMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &UseCaseMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectUsernameParam2 sets up expected param username for UseCase.Login
func (mmLogin *mUseCaseMockLogin) ExpectUsernameParam2(username string) *mUseCaseMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UseCaseMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UseCaseMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("UseCaseMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &UseCaseMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.username = &username
	mmLogin.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectPasswordParam3 sets up expected param password for UseCase.Login
func (mmLogin *mUseCaseMockLogin) ExpectPasswordParam3(password string) *mUseCaseMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UseCaseMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UseCaseMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("UseCaseMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &UseCaseMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.password = &password
	mmLogin.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the UseCase.Login
func (mmLogin *mUseCaseMockLogin) Inspect(f func(ctx context.Context, username string, password string)) *mUseCaseMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for UseCaseMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by UseCase.Login
func (mmLogin *mUseCaseMockLogin) Return(s1 string, up1 *entity.UserResponse, err error) *UseCaseMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UseCaseMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &UseCaseMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &UseCaseMockLoginResults{s1, up1, err}
	mmLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// Set uses given function f to mock the UseCase.Login method
func (mmLogin *mUseCaseMockLogin) Set(f func(ctx context.Context, username string, password string) (s1 string, up1 *entity.UserResponse, err error)) *UseCaseMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the UseCase.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the UseCase.Login method")
	}

	mmLogin.mock.funcLogin = f
	mmLogin.mock.funcLoginOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// When sets expectation for the UseCase.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mUseCaseMockLogin) When(ctx context.Context, username string, password string) *UseCaseMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("UseCaseMock.Login mock is already set by Set")
	}

	expectation := &UseCaseMockLoginExpectation{
		mock:               mmLogin.mock,
		params:             &UseCaseMockLoginParams{ctx, username, password},
		expectationOrigins: UseCaseMockLoginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up UseCase.Login return parameters for the expectation previously defined by the When method
func (e *UseCaseMockLoginExpectation) Then(s1 string, up1 *entity.UserResponse, err error) *UseCaseMock {
	e.results = &UseCaseMockLoginResults{s1, up1, err}
	return e.mock
}

// Times sets number of times UseCase.Login should be invoked
func (mmLogin *mUseCaseMockLogin) Times(n uint64) *mUseCaseMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of UseCaseMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	mmLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogin
}

func (mmLogin *mUseCaseMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements mm_auth.UseCase
func (mmLogin *UseCaseMock) Login(ctx context.Context, username string, password string) (s1 string, up1 *entity.UserResponse, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	mmLogin.t.Helper()

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, username, password)
	}

	mm_params := UseCaseMockLoginParams{ctx, username, password}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.up1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := UseCaseMockLoginParams{ctx, username, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("UseCaseMock.Login got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmLogin.t.Errorf("UseCaseMock.Login got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmLogin.t.Errorf("UseCaseMock.Login got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("UseCaseMock.Login got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogin.LoginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the UseCaseMock.Login")
		}
		return (*mm_results).s1, (*mm_results).up1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, username, password)
	}
	mmLogin.t.Fatalf("Unexpected call to UseCaseMock.Login. %v %v %v", ctx, username, password)
	return
}

// LoginAfterCounter returns a count of finished UseCaseMock.Login invocations
func (mmLogin *UseCaseMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of UseCaseMock.Login invocations
func (mmLogin *UseCaseMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mUseCaseMockLogin) Calls() []*UseCaseMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*UseCaseMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *UseCaseMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.Login at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UseCaseMock.Login at\n%s", m.LoginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UseCaseMock.Login at\n%s with params: %#v", m.LoginMock.defaultExpectation.expectationOrigins.origin, *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Errorf("Expected call to UseCaseMock.Login at\n%s", m.funcLoginOrigin)
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to UseCaseMock.Login at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), m.LoginMock.expectedInvocationsOrigin, afterLoginCounter)
	}
}

type mUseCaseMockRegister struct {
	optional           bool
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockRegisterExpectation
	expectations       []*UseCaseMockRegisterExpectation

	callArgs []*UseCaseMockRegisterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UseCaseMockRegisterExpectation specifies expectation struct of the UseCase.Register
type UseCaseMockRegisterExpectation struct {
	mock               *UseCaseMock
	params             *UseCaseMockRegisterParams
	paramPtrs          *UseCaseMockRegisterParamPtrs
	expectationOrigins UseCaseMockRegisterExpectationOrigins
	results            *UseCaseMockRegisterResults
	returnOrigin       string
	Counter            uint64
}

// UseCaseMockRegisterParams contains parameters of the UseCase.Register
type UseCaseMockRegisterParams struct {
	ctx      context.Context
	username string
	password string
}

// UseCaseMockRegisterParamPtrs contains pointers to parameters of the UseCase.Register
type UseCaseMockRegisterParamPtrs struct {
	ctx      *context.Context
	username *string
	password *string
}

// UseCaseMockRegisterResults contains results of the UseCase.Register
type UseCaseMockRegisterResults struct {
	up1 *entity.UserResponse
	err error
}

// UseCaseMockRegisterOrigins contains origins of expectations of the UseCase.Register
type UseCaseMockRegisterExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegister *mUseCaseMockRegister) Optional() *mUseCaseMockRegister {
	mmRegister.optional = true
	return mmRegister
}

// Expect sets up expected params for UseCase.Register
func (mmRegister *mUseCaseMockRegister) Expect(ctx context.Context, username string, password string) *mUseCaseMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UseCaseMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UseCaseMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.paramPtrs != nil {
		mmRegister.mock.t.Fatalf("UseCaseMock.Register mock is already set by ExpectParams functions")
	}

	mmRegister.defaultExpectation.params = &UseCaseMockRegisterParams{ctx, username, password}
	mmRegister.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegister.expectations {
		if minimock.Equal(e.params, mmRegister.defaultExpectation.params) {
			mmRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegister.defaultExpectation.params)
		}
	}

	return mmRegister
}

// ExpectCtxParam1 sets up expected param ctx for UseCase.Register
func (mmRegister *mUseCaseMockRegister) ExpectCtxParam1(ctx context.Context) *mUseCaseMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UseCaseMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UseCaseMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("UseCaseMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &UseCaseMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.ctx = &ctx
	mmRegister.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRegister
}

// ExpectUsernameParam2 sets up expected param username for UseCase.Register
func (mmRegister *mUseCaseMockRegister) ExpectUsernameParam2(username string) *mUseCaseMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UseCaseMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UseCaseMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("UseCaseMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &UseCaseMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.username = &username
	mmRegister.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmRegister
}

// ExpectPasswordParam3 sets up expected param password for UseCase.Register
func (mmRegister *mUseCaseMockRegister) ExpectPasswordParam3(password string) *mUseCaseMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UseCaseMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UseCaseMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("UseCaseMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &UseCaseMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.password = &password
	mmRegister.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmRegister
}

// Inspect accepts an inspector function that has same arguments as the UseCase.Register
func (mmRegister *mUseCaseMockRegister) Inspect(f func(ctx context.Context, username string, password string)) *mUseCaseMockRegister {
	if mmRegister.mock.inspectFuncRegister != nil {
		mmRegister.mock.t.Fatalf("Inspect function is already set for UseCaseMock.Register")
	}

	mmRegister.mock.inspectFuncRegister = f

	return mmRegister
}

// Return sets up results that will be returned by UseCase.Register
func (mmRegister *mUseCaseMockRegister) Return(up1 *entity.UserResponse, err error) *UseCaseMock {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UseCaseMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &UseCaseMockRegisterExpectation{mock: mmRegister.mock}
	}
	mmRegister.defaultExpectation.results = &UseCaseMockRegisterResults{up1, err}
	mmRegister.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegister.mock
}

// Set uses given function f to mock the UseCase.Register method
func (mmRegister *mUseCaseMockRegister) Set(f func(ctx context.Context, username string, password string) (up1 *entity.UserResponse, err error)) *UseCaseMock {
	if mmRegister.defaultExpectation != nil {
		mmRegister.mock.t.Fatalf("Default expectation is already set for the UseCase.Register method")
	}

	if len(mmRegister.expectations) > 0 {
		mmRegister.mock.t.Fatalf("Some expectations are already set for the UseCase.Register method")
	}

	mmRegister.mock.funcRegister = f
	mmRegister.mock.funcRegisterOrigin = minimock.CallerInfo(1)
	return mmRegister.mock
}

// When sets expectation for the UseCase.Register which will trigger the result defined by the following
// Then helper
func (mmRegister *mUseCaseMockRegister) When(ctx context.Context, username string, password string) *UseCaseMockRegisterExpectation {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("UseCaseMock.Register mock is already set by Set")
	}

	expectation := &UseCaseMockRegisterExpectation{
		mock:               mmRegister.mock,
		params:             &UseCaseMockRegisterParams{ctx, username, password},
		expectationOrigins: UseCaseMockRegisterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegister.expectations = append(mmRegister.expectations, expectation)
	return expectation
}

// Then sets up UseCase.Register return parameters for the expectation previously defined by the When method
func (e *UseCaseMockRegisterExpectation) Then(up1 *entity.UserResponse, err error) *UseCaseMock {
	e.results = &UseCaseMockRegisterResults{up1, err}
	return e.mock
}

// Times sets number of times UseCase.Register should be invoked
func (mmRegister *mUseCaseMockRegister) Times(n uint64) *mUseCaseMockRegister {
	if n == 0 {
		mmRegister.mock.t.Fatalf("Times of UseCaseMock.Register mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegister.expectedInvocations, n)
	mmRegister.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegister
}

func (mmRegister *mUseCaseMockRegister) invocationsDone() bool {
	if len(mmRegister.expectations) == 0 && mmRegister.defaultExpectation == nil && mmRegister.mock.funcRegister == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegister.mock.afterRegisterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegister.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Register implements mm_auth.UseCase
func (mmRegister *UseCaseMock) Register(ctx context.Context, username string, password string) (up1 *entity.UserResponse, err error) {
	mm_atomic.AddUint64(&mmRegister.beforeRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegister.afterRegisterCounter, 1)

	mmRegister.t.Helper()

	if mmRegister.inspectFuncRegister != nil {
		mmRegister.inspectFuncRegister(ctx, username, password)
	}

	mm_params := UseCaseMockRegisterParams{ctx, username, password}

	// Record call args
	mmRegister.RegisterMock.mutex.Lock()
	mmRegister.RegisterMock.callArgs = append(mmRegister.RegisterMock.callArgs, &mm_params)
	mmRegister.RegisterMock.mutex.Unlock()

	for _, e := range mmRegister.RegisterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmRegister.RegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegister.RegisterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegister.RegisterMock.defaultExpectation.params
		mm_want_ptrs := mmRegister.RegisterMock.defaultExpectation.paramPtrs

		mm_got := UseCaseMockRegisterParams{ctx, username, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRegister.t.Errorf("UseCaseMock.Register got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmRegister.t.Errorf("UseCaseMock.Register got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmRegister.t.Errorf("UseCaseMock.Register got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegister.t.Errorf("UseCaseMock.Register got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegister.RegisterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegister.RegisterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegister.t.Fatal("No results are set for the UseCaseMock.Register")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmRegister.funcRegister != nil {
		return mmRegister.funcRegister(ctx, username, password)
	}
	mmRegister.t.Fatalf("Unexpected call to UseCaseMock.Register. %v %v %v", ctx, username, password)
	return
}

// RegisterAfterCounter returns a count of finished UseCaseMock.Register invocations
func (mmRegister *UseCaseMock) RegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.afterRegisterCounter)
}

// RegisterBeforeCounter returns a count of UseCaseMock.Register invocations
func (mmRegister *UseCaseMock) RegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.beforeRegisterCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.Register.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegister *mUseCaseMockRegister) Calls() []*UseCaseMockRegisterParams {
	mmRegister.mutex.RLock()

	argCopy := make([]*UseCaseMockRegisterParams, len(mmRegister.callArgs))
	copy(argCopy, mmRegister.callArgs)

	mmRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterDone returns true if the count of the Register invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockRegisterDone() bool {
	if m.RegisterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterMock.invocationsDone()
}

// MinimockRegisterInspect logs each unmet expectation
func (m *UseCaseMock) MinimockRegisterInspect() {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.Register at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterCounter := mm_atomic.LoadUint64(&m.afterRegisterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && afterRegisterCounter < 1 {
		if m.RegisterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UseCaseMock.Register at\n%s", m.RegisterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UseCaseMock.Register at\n%s with params: %#v", m.RegisterMock.defaultExpectation.expectationOrigins.origin, *m.RegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && afterRegisterCounter < 1 {
		m.t.Errorf("Expected call to UseCaseMock.Register at\n%s", m.funcRegisterOrigin)
	}

	if !m.RegisterMock.invocationsDone() && afterRegisterCounter > 0 {
		m.t.Errorf("Expected %d calls to UseCaseMock.Register at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterMock.expectedInvocations), m.RegisterMock.expectedInvocationsOrigin, afterRegisterCounter)
	}
}

type mUseCaseMockVerifyToken struct {
	optional           bool
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockVerifyTokenExpectation
	expectations       []*UseCaseMockVerifyTokenExpectation

	callArgs []*UseCaseMockVerifyTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UseCaseMockVerifyTokenExpectation specifies expectation struct of the UseCase.VerifyToken
type UseCaseMockVerifyTokenExpectation struct {
	mock               *UseCaseMock
	params             *UseCaseMockVerifyTokenParams
	paramPtrs          *UseCaseMockVerifyTokenParamPtrs
	expectationOrigins UseCaseMockVerifyTokenExpectationOrigins
	results            *UseCaseMockVerifyTokenResults
	returnOrigin       string
	Counter            uint64
}

// UseCaseMockVerifyTokenParams contains parameters of the UseCase.VerifyToken
type UseCaseMockVerifyTokenParams struct {
	ctx   context.Context
	token string
}

// UseCaseMockVerifyTokenParamPtrs contains pointers to parameters of the UseCase.VerifyToken
type UseCaseMockVerifyTokenParamPtrs struct {
	ctx   *context.Context
	token *string
}

// UseCaseMockVerifyTokenResults contains results of the UseCase.VerifyToken
type UseCaseMockVerifyTokenResults struct {
	u1  uint64
	err error
}

// UseCaseMockVerifyTokenOrigins contains origins of expectations of the UseCase.VerifyToken
type UseCaseMockVerifyTokenExpectationOrigins struct {
	origin      string
	originCtx   string
	originToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmVerifyToken *mUseCaseMockVerifyToken) Optional() *mUseCaseMockVerifyToken {
	mmVerifyToken.optional = true
	return mmVerifyToken
}

// Expect sets up expected params for UseCase.VerifyToken
func (mmVerifyToken *mUseCaseMockVerifyToken) Expect(ctx context.Context, token string) *mUseCaseMockVerifyToken {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("UseCaseMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &UseCaseMockVerifyTokenExpectation{}
	}

	if mmVerifyToken.defaultExpectation.paramPtrs != nil {
		mmVerifyToken.mock.t.Fatalf("UseCaseMock.VerifyToken mock is already set by ExpectParams functions")
	}

	mmVerifyToken.defaultExpectation.params = &UseCaseMockVerifyTokenParams{ctx, token}
	mmVerifyToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmVerifyToken.expectations {
		if minimock.Equal(e.params, mmVerifyToken.defaultExpectation.params) {
			mmVerifyToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVerifyToken.defaultExpectation.params)
		}
	}

	return mmVerifyToken
}

// ExpectCtxParam1 sets up expected param ctx for UseCase.VerifyToken
func (mmVerifyToken *mUseCaseMockVerifyToken) ExpectCtxParam1(ctx context.Context) *mUseCaseMockVerifyToken {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("UseCaseMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &UseCaseMockVerifyTokenExpectation{}
	}

	if mmVerifyToken.defaultExpectation.params != nil {
		mmVerifyToken.mock.t.Fatalf("UseCaseMock.VerifyToken mock is already set by Expect")
	}

	if mmVerifyToken.defaultExpectation.paramPtrs == nil {
		mmVerifyToken.defaultExpectation.paramPtrs = &UseCaseMockVerifyTokenParamPtrs{}
	}
	mmVerifyToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmVerifyToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmVerifyToken
}

// ExpectTokenParam2 sets up expected param token for UseCase.VerifyToken
func (mmVerifyToken *mUseCaseMockVerifyToken) ExpectTokenParam2(token string) *mUseCaseMockVerifyToken {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("UseCaseMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &UseCaseMockVerifyTokenExpectation{}
	}

	if mmVerifyToken.defaultExpectation.params != nil {
		mmVerifyToken.mock.t.Fatalf("UseCaseMock.VerifyToken mock is already set by Expect")
	}

	if mmVerifyToken.defaultExpectation.paramPtrs == nil {
		mmVerifyToken.defaultExpectation.paramPtrs = &UseCaseMockVerifyTokenParamPtrs{}
	}
	mmVerifyToken.defaultExpectation.paramPtrs.token = &token
	mmVerifyToken.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmVerifyToken
}

// Inspect accepts an inspector function that has same arguments as the UseCase.VerifyToken
func (mmVerifyToken *mUseCaseMockVerifyToken) Inspect(f func(ctx context.Context, token string)) *mUseCaseMockVerifyToken {
	if mmVerifyToken.mock.inspectFuncVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("Inspect function is already set for UseCaseMock.VerifyToken")
	}

	mmVerifyToken.mock.inspectFuncVerifyToken = f

	return mmVerifyToken
}

// Return sets up results that will be returned by UseCase.VerifyToken
func (mmVerifyToken *mUseCaseMockVerifyToken) Return(u1 uint64, err error) *UseCaseMock {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("UseCaseMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &UseCaseMockVerifyTokenExpectation{mock: mmVerifyToken.mock}
	}
	mmVerifyToken.defaultExpectation.results = &UseCaseMockVerifyTokenResults{u1, err}
	mmVerifyToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmVerifyToken.mock
}

// Set uses given function f to mock the UseCase.VerifyToken method
func (mmVerifyToken *mUseCaseMockVerifyToken) Set(f func(ctx context.Context, token string) (u1 uint64, err error)) *UseCaseMock {
	if mmVerifyToken.defaultExpectation != nil {
		mmVerifyToken.mock.t.Fatalf("Default expectation is already set for the UseCase.VerifyToken method")
	}

	if len(mmVerifyToken.expectations) > 0 {
		mmVerifyToken.mock.t.Fatalf("Some expectations are already set for the UseCase.VerifyToken method")
	}

	mmVerifyToken.mock.funcVerifyToken = f
	mmVerifyToken.mock.funcVerifyTokenOrigin = minimock.CallerInfo(1)
	return mmVerifyToken.mock
}

// When sets expectation for the UseCase.VerifyToken which will trigger the result defined by the following
// Then helper
func (mmVerifyToken *mUseCaseMockVerifyToken) When(ctx context.Context, token string) *UseCaseMockVerifyTokenExpectation {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("UseCaseMock.VerifyToken mock is already set by Set")
	}

	expectation := &UseCaseMockVerifyTokenExpectation{
		mock:               mmVerifyToken.mock,
		params:             &UseCaseMockVerifyTokenParams{ctx, token},
		expectationOrigins: UseCaseMockVerifyTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmVerifyToken.expectations = append(mmVerifyToken.expectations, expectation)
	return expectation
}

// Then sets up UseCase.VerifyToken return parameters for the expectation previously defined by the When method
func (e *UseCaseMockVerifyTokenExpectation) Then(u1 uint64, err error) *UseCaseMock {
	e.results = &UseCaseMockVerifyTokenResults{u1, err}
	return e.mock
}

// Times sets number of times UseCase.VerifyToken should be invoked
func (mmVerifyToken *mUseCaseMockVerifyToken) Times(n uint64) *mUseCaseMockVerifyToken {
	if n == 0 {
		mmVerifyToken.mock.t.Fatalf("Times of UseCaseMock.VerifyToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmVerifyToken.expectedInvocations, n)
	mmVerifyToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmVerifyToken
}

func (mmVerifyToken *mUseCaseMockVerifyToken) invocationsDone() bool {
	if len(mmVerifyToken.expectations) == 0 && mmVerifyToken.defaultExpectation == nil && mmVerifyToken.mock.funcVerifyToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmVerifyToken.mock.afterVerifyTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmVerifyToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// VerifyToken implements mm_auth.UseCase
func (mmVerifyToken *UseCaseMock) VerifyToken(ctx context.Context, token string) (u1 uint64, err error) {
	mm_atomic.AddUint64(&mmVerifyToken.beforeVerifyTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmVerifyToken.afterVerifyTokenCounter, 1)

	mmVerifyToken.t.Helper()

	if mmVerifyToken.inspectFuncVerifyToken != nil {
		mmVerifyToken.inspectFuncVerifyToken(ctx, token)
	}

	mm_params := UseCaseMockVerifyTokenParams{ctx, token}

	// Record call args
	mmVerifyToken.VerifyTokenMock.mutex.Lock()
	mmVerifyToken.VerifyTokenMock.callArgs = append(mmVerifyToken.VerifyTokenMock.callArgs, &mm_params)
	mmVerifyToken.VerifyTokenMock.mutex.Unlock()

	for _, e := range mmVerifyToken.VerifyTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmVerifyToken.VerifyTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVerifyToken.VerifyTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmVerifyToken.VerifyTokenMock.defaultExpectation.params
		mm_want_ptrs := mmVerifyToken.VerifyTokenMock.defaultExpectation.paramPtrs

		mm_got := UseCaseMockVerifyTokenParams{ctx, token}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmVerifyToken.t.Errorf("UseCaseMock.VerifyToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyToken.VerifyTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmVerifyToken.t.Errorf("UseCaseMock.VerifyToken got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyToken.VerifyTokenMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVerifyToken.t.Errorf("UseCaseMock.VerifyToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmVerifyToken.VerifyTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmVerifyToken.VerifyTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmVerifyToken.t.Fatal("No results are set for the UseCaseMock.VerifyToken")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmVerifyToken.funcVerifyToken != nil {
		return mmVerifyToken.funcVerifyToken(ctx, token)
	}
	mmVerifyToken.t.Fatalf("Unexpected call to UseCaseMock.VerifyToken. %v %v", ctx, token)
	return
}

// VerifyTokenAfterCounter returns a count of finished UseCaseMock.VerifyToken invocations
func (mmVerifyToken *UseCaseMock) VerifyTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyToken.afterVerifyTokenCounter)
}

// VerifyTokenBeforeCounter returns a count of UseCaseMock.VerifyToken invocations
func (mmVerifyToken *UseCaseMock) VerifyTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyToken.beforeVerifyTokenCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.VerifyToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVerifyToken *mUseCaseMockVerifyToken) Calls() []*UseCaseMockVerifyTokenParams {
	mmVerifyToken.mutex.RLock()

	argCopy := make([]*UseCaseMockVerifyTokenParams, len(mmVerifyToken.callArgs))
	copy(argCopy, mmVerifyToken.callArgs)

	mmVerifyToken.mutex.RUnlock()

	return argCopy
}

// MinimockVerifyTokenDone returns true if the count of the VerifyToken invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockVerifyTokenDone() bool {
	if m.VerifyTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.VerifyTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.VerifyTokenMock.invocationsDone()
}

// MinimockVerifyTokenInspect logs each unmet expectation
func (m *UseCaseMock) MinimockVerifyTokenInspect() {
	for _, e := range m.VerifyTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.VerifyToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterVerifyTokenCounter := mm_atomic.LoadUint64(&m.afterVerifyTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.VerifyTokenMock.defaultExpectation != nil && afterVerifyTokenCounter < 1 {
		if m.VerifyTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UseCaseMock.VerifyToken at\n%s", m.VerifyTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UseCaseMock.VerifyToken at\n%s with params: %#v", m.VerifyTokenMock.defaultExpectation.expectationOrigins.origin, *m.VerifyTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVerifyToken != nil && afterVerifyTokenCounter < 1 {
		m.t.Errorf("Expected call to UseCaseMock.VerifyToken at\n%s", m.funcVerifyTokenOrigin)
	}

	if !m.VerifyTokenMock.invocationsDone() && afterVerifyTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to UseCaseMock.VerifyToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.VerifyTokenMock.expectedInvocations), m.VerifyTokenMock.expectedInvocationsOrigin, afterVerifyTokenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UseCaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockLoginInspect()

			m.MinimockRegisterInspect()

			m.MinimockVerifyTokenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UseCaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UseCaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockLoginDone() &&
		m.MinimockRegisterDone() &&
		m.MinimockVerifyTokenDone()
}
