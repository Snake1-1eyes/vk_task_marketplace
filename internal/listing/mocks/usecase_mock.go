// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Snake1-1eyes/vk_task_marketplace/internal/listing.UseCase -o usecase_mock.go -n UseCaseMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Snake1-1eyes/vk_task_marketplace/internal/entity"
	"github.com/gojuno/minimock/v3"
)

// UseCaseMock implements mm_listing.UseCase
type UseCaseMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateListing          func(ctx context.Context, authorID uint64, title string, description string, imageURL string, price float32) (lp1 *entity.Listing, err error)
	funcCreateListingOrigin    string
	inspectFuncCreateListing   func(ctx context.Context, authorID uint64, title string, description string, imageURL string, price float32)
	afterCreateListingCounter  uint64
	beforeCreateListingCounter uint64
	CreateListingMock          mUseCaseMockCreateListing

	funcGetListings          func(ctx context.Context, page uint32, perPage uint32, sortBy string, sortDesc bool, minPrice *float32, maxPrice *float32) (lpa1 []*entity.Listing, u1 uint32, err error)
	funcGetListingsOrigin    string
	inspectFuncGetListings   func(ctx context.Context, page uint32, perPage uint32, sortBy string, sortDesc bool, minPrice *float32, maxPrice *float32)
	afterGetListingsCounter  uint64
	beforeGetListingsCounter uint64
	GetListingsMock          mUseCaseMockGetListings
}

// NewUseCaseMock returns a mock for mm_listing.UseCase
func NewUseCaseMock(t minimock.Tester) *UseCaseMock {
	m := &UseCaseMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateListingMock = mUseCaseMockCreateListing{mock: m}
	m.CreateListingMock.callArgs = []*UseCaseMockCreateListingParams{}

	m.GetListingsMock = mUseCaseMockGetListings{mock: m}
	m.GetListingsMock.callArgs = []*UseCaseMockGetListingsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUseCaseMockCreateListing struct {
	optional           bool
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockCreateListingExpectation
	expectations       []*UseCaseMockCreateListingExpectation

	callArgs []*UseCaseMockCreateListingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UseCaseMockCreateListingExpectation specifies expectation struct of the UseCase.CreateListing
type UseCaseMockCreateListingExpectation struct {
	mock               *UseCaseMock
	params             *UseCaseMockCreateListingParams
	paramPtrs          *UseCaseMockCreateListingParamPtrs
	expectationOrigins UseCaseMockCreateListingExpectationOrigins
	results            *UseCaseMockCreateListingResults
	returnOrigin       string
	Counter            uint64
}

// UseCaseMockCreateListingParams contains parameters of the UseCase.CreateListing
type UseCaseMockCreateListingParams struct {
	ctx         context.Context
	authorID    uint64
	title       string
	description string
	imageURL    string
	price       float32
}

// UseCaseMockCreateListingParamPtrs contains pointers to parameters of the UseCase.CreateListing
type UseCaseMockCreateListingParamPtrs struct {
	ctx         *context.Context
	authorID    *uint64
	title       *string
	description *string
	imageURL    *string
	price       *float32
}

// UseCaseMockCreateListingResults contains results of the UseCase.CreateListing
type UseCaseMockCreateListingResults struct {
	lp1 *entity.Listing
	err error
}

// UseCaseMockCreateListingOrigins contains origins of expectations of the UseCase.CreateListing
type UseCaseMockCreateListingExpectationOrigins struct {
	origin            string
	originCtx         string
	originAuthorID    string
	originTitle       string
	originDescription string
	originImageURL    string
	originPrice       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateListing *mUseCaseMockCreateListing) Optional() *mUseCaseMockCreateListing {
	mmCreateListing.optional = true
	return mmCreateListing
}

// Expect sets up expected params for UseCase.CreateListing
func (mmCreateListing *mUseCaseMockCreateListing) Expect(ctx context.Context, authorID uint64, title string, description string, imageURL string, price float32) *mUseCaseMockCreateListing {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &UseCaseMockCreateListingExpectation{}
	}

	if mmCreateListing.defaultExpectation.paramPtrs != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by ExpectParams functions")
	}

	mmCreateListing.defaultExpectation.params = &UseCaseMockCreateListingParams{ctx, authorID, title, description, imageURL, price}
	mmCreateListing.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateListing.expectations {
		if minimock.Equal(e.params, mmCreateListing.defaultExpectation.params) {
			mmCreateListing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateListing.defaultExpectation.params)
		}
	}

	return mmCreateListing
}

// ExpectCtxParam1 sets up expected param ctx for UseCase.CreateListing
func (mmCreateListing *mUseCaseMockCreateListing) ExpectCtxParam1(ctx context.Context) *mUseCaseMockCreateListing {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &UseCaseMockCreateListingExpectation{}
	}

	if mmCreateListing.defaultExpectation.params != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Expect")
	}

	if mmCreateListing.defaultExpectation.paramPtrs == nil {
		mmCreateListing.defaultExpectation.paramPtrs = &UseCaseMockCreateListingParamPtrs{}
	}
	mmCreateListing.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateListing.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateListing
}

// ExpectAuthorIDParam2 sets up expected param authorID for UseCase.CreateListing
func (mmCreateListing *mUseCaseMockCreateListing) ExpectAuthorIDParam2(authorID uint64) *mUseCaseMockCreateListing {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &UseCaseMockCreateListingExpectation{}
	}

	if mmCreateListing.defaultExpectation.params != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Expect")
	}

	if mmCreateListing.defaultExpectation.paramPtrs == nil {
		mmCreateListing.defaultExpectation.paramPtrs = &UseCaseMockCreateListingParamPtrs{}
	}
	mmCreateListing.defaultExpectation.paramPtrs.authorID = &authorID
	mmCreateListing.defaultExpectation.expectationOrigins.originAuthorID = minimock.CallerInfo(1)

	return mmCreateListing
}

// ExpectTitleParam3 sets up expected param title for UseCase.CreateListing
func (mmCreateListing *mUseCaseMockCreateListing) ExpectTitleParam3(title string) *mUseCaseMockCreateListing {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &UseCaseMockCreateListingExpectation{}
	}

	if mmCreateListing.defaultExpectation.params != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Expect")
	}

	if mmCreateListing.defaultExpectation.paramPtrs == nil {
		mmCreateListing.defaultExpectation.paramPtrs = &UseCaseMockCreateListingParamPtrs{}
	}
	mmCreateListing.defaultExpectation.paramPtrs.title = &title
	mmCreateListing.defaultExpectation.expectationOrigins.originTitle = minimock.CallerInfo(1)

	return mmCreateListing
}

// ExpectDescriptionParam4 sets up expected param description for UseCase.CreateListing
func (mmCreateListing *mUseCaseMockCreateListing) ExpectDescriptionParam4(description string) *mUseCaseMockCreateListing {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &UseCaseMockCreateListingExpectation{}
	}

	if mmCreateListing.defaultExpectation.params != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Expect")
	}

	if mmCreateListing.defaultExpectation.paramPtrs == nil {
		mmCreateListing.defaultExpectation.paramPtrs = &UseCaseMockCreateListingParamPtrs{}
	}
	mmCreateListing.defaultExpectation.paramPtrs.description = &description
	mmCreateListing.defaultExpectation.expectationOrigins.originDescription = minimock.CallerInfo(1)

	return mmCreateListing
}

// ExpectImageURLParam5 sets up expected param imageURL for UseCase.CreateListing
func (mmCreateListing *mUseCaseMockCreateListing) ExpectImageURLParam5(imageURL string) *mUseCaseMockCreateListing {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &UseCaseMockCreateListingExpectation{}
	}

	if mmCreateListing.defaultExpectation.params != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Expect")
	}

	if mmCreateListing.defaultExpectation.paramPtrs == nil {
		mmCreateListing.defaultExpectation.paramPtrs = &UseCaseMockCreateListingParamPtrs{}
	}
	mmCreateListing.defaultExpectation.paramPtrs.imageURL = &imageURL
	mmCreateListing.defaultExpectation.expectationOrigins.originImageURL = minimock.CallerInfo(1)

	return mmCreateListing
}

// ExpectPriceParam6 sets up expected param price for UseCase.CreateListing
func (mmCreateListing *mUseCaseMockCreateListing) ExpectPriceParam6(price float32) *mUseCaseMockCreateListing {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &UseCaseMockCreateListingExpectation{}
	}

	if mmCreateListing.defaultExpectation.params != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Expect")
	}

	if mmCreateListing.defaultExpectation.paramPtrs == nil {
		mmCreateListing.defaultExpectation.paramPtrs = &UseCaseMockCreateListingParamPtrs{}
	}
	mmCreateListing.defaultExpectation.paramPtrs.price = &price
	mmCreateListing.defaultExpectation.expectationOrigins.originPrice = minimock.CallerInfo(1)

	return mmCreateListing
}

// Inspect accepts an inspector function that has same arguments as the UseCase.CreateListing
func (mmCreateListing *mUseCaseMockCreateListing) Inspect(f func(ctx context.Context, authorID uint64, title string, description string, imageURL string, price float32)) *mUseCaseMockCreateListing {
	if mmCreateListing.mock.inspectFuncCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("Inspect function is already set for UseCaseMock.CreateListing")
	}

	mmCreateListing.mock.inspectFuncCreateListing = f

	return mmCreateListing
}

// Return sets up results that will be returned by UseCase.CreateListing
func (mmCreateListing *mUseCaseMockCreateListing) Return(lp1 *entity.Listing, err error) *UseCaseMock {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &UseCaseMockCreateListingExpectation{mock: mmCreateListing.mock}
	}
	mmCreateListing.defaultExpectation.results = &UseCaseMockCreateListingResults{lp1, err}
	mmCreateListing.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateListing.mock
}

// Set uses given function f to mock the UseCase.CreateListing method
func (mmCreateListing *mUseCaseMockCreateListing) Set(f func(ctx context.Context, authorID uint64, title string, description string, imageURL string, price float32) (lp1 *entity.Listing, err error)) *UseCaseMock {
	if mmCreateListing.defaultExpectation != nil {
		mmCreateListing.mock.t.Fatalf("Default expectation is already set for the UseCase.CreateListing method")
	}

	if len(mmCreateListing.expectations) > 0 {
		mmCreateListing.mock.t.Fatalf("Some expectations are already set for the UseCase.CreateListing method")
	}

	mmCreateListing.mock.funcCreateListing = f
	mmCreateListing.mock.funcCreateListingOrigin = minimock.CallerInfo(1)
	return mmCreateListing.mock
}

// When sets expectation for the UseCase.CreateListing which will trigger the result defined by the following
// Then helper
func (mmCreateListing *mUseCaseMockCreateListing) When(ctx context.Context, authorID uint64, title string, description string, imageURL string, price float32) *UseCaseMockCreateListingExpectation {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("UseCaseMock.CreateListing mock is already set by Set")
	}

	expectation := &UseCaseMockCreateListingExpectation{
		mock:               mmCreateListing.mock,
		params:             &UseCaseMockCreateListingParams{ctx, authorID, title, description, imageURL, price},
		expectationOrigins: UseCaseMockCreateListingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateListing.expectations = append(mmCreateListing.expectations, expectation)
	return expectation
}

// Then sets up UseCase.CreateListing return parameters for the expectation previously defined by the When method
func (e *UseCaseMockCreateListingExpectation) Then(lp1 *entity.Listing, err error) *UseCaseMock {
	e.results = &UseCaseMockCreateListingResults{lp1, err}
	return e.mock
}

// Times sets number of times UseCase.CreateListing should be invoked
func (mmCreateListing *mUseCaseMockCreateListing) Times(n uint64) *mUseCaseMockCreateListing {
	if n == 0 {
		mmCreateListing.mock.t.Fatalf("Times of UseCaseMock.CreateListing mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateListing.expectedInvocations, n)
	mmCreateListing.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateListing
}

func (mmCreateListing *mUseCaseMockCreateListing) invocationsDone() bool {
	if len(mmCreateListing.expectations) == 0 && mmCreateListing.defaultExpectation == nil && mmCreateListing.mock.funcCreateListing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateListing.mock.afterCreateListingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateListing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateListing implements mm_listing.UseCase
func (mmCreateListing *UseCaseMock) CreateListing(ctx context.Context, authorID uint64, title string, description string, imageURL string, price float32) (lp1 *entity.Listing, err error) {
	mm_atomic.AddUint64(&mmCreateListing.beforeCreateListingCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateListing.afterCreateListingCounter, 1)

	mmCreateListing.t.Helper()

	if mmCreateListing.inspectFuncCreateListing != nil {
		mmCreateListing.inspectFuncCreateListing(ctx, authorID, title, description, imageURL, price)
	}

	mm_params := UseCaseMockCreateListingParams{ctx, authorID, title, description, imageURL, price}

	// Record call args
	mmCreateListing.CreateListingMock.mutex.Lock()
	mmCreateListing.CreateListingMock.callArgs = append(mmCreateListing.CreateListingMock.callArgs, &mm_params)
	mmCreateListing.CreateListingMock.mutex.Unlock()

	for _, e := range mmCreateListing.CreateListingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmCreateListing.CreateListingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateListing.CreateListingMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateListing.CreateListingMock.defaultExpectation.params
		mm_want_ptrs := mmCreateListing.CreateListingMock.defaultExpectation.paramPtrs

		mm_got := UseCaseMockCreateListingParams{ctx, authorID, title, description, imageURL, price}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateListing.t.Errorf("UseCaseMock.CreateListing got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateListing.CreateListingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.authorID != nil && !minimock.Equal(*mm_want_ptrs.authorID, mm_got.authorID) {
				mmCreateListing.t.Errorf("UseCaseMock.CreateListing got unexpected parameter authorID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateListing.CreateListingMock.defaultExpectation.expectationOrigins.originAuthorID, *mm_want_ptrs.authorID, mm_got.authorID, minimock.Diff(*mm_want_ptrs.authorID, mm_got.authorID))
			}

			if mm_want_ptrs.title != nil && !minimock.Equal(*mm_want_ptrs.title, mm_got.title) {
				mmCreateListing.t.Errorf("UseCaseMock.CreateListing got unexpected parameter title, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateListing.CreateListingMock.defaultExpectation.expectationOrigins.originTitle, *mm_want_ptrs.title, mm_got.title, minimock.Diff(*mm_want_ptrs.title, mm_got.title))
			}

			if mm_want_ptrs.description != nil && !minimock.Equal(*mm_want_ptrs.description, mm_got.description) {
				mmCreateListing.t.Errorf("UseCaseMock.CreateListing got unexpected parameter description, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateListing.CreateListingMock.defaultExpectation.expectationOrigins.originDescription, *mm_want_ptrs.description, mm_got.description, minimock.Diff(*mm_want_ptrs.description, mm_got.description))
			}

			if mm_want_ptrs.imageURL != nil && !minimock.Equal(*mm_want_ptrs.imageURL, mm_got.imageURL) {
				mmCreateListing.t.Errorf("UseCaseMock.CreateListing got unexpected parameter imageURL, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateListing.CreateListingMock.defaultExpectation.expectationOrigins.originImageURL, *mm_want_ptrs.imageURL, mm_got.imageURL, minimock.Diff(*mm_want_ptrs.imageURL, mm_got.imageURL))
			}

			if mm_want_ptrs.price != nil && !minimock.Equal(*mm_want_ptrs.price, mm_got.price) {
				mmCreateListing.t.Errorf("UseCaseMock.CreateListing got unexpected parameter price, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateListing.CreateListingMock.defaultExpectation.expectationOrigins.originPrice, *mm_want_ptrs.price, mm_got.price, minimock.Diff(*mm_want_ptrs.price, mm_got.price))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateListing.t.Errorf("UseCaseMock.CreateListing got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateListing.CreateListingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateListing.CreateListingMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateListing.t.Fatal("No results are set for the UseCaseMock.CreateListing")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmCreateListing.funcCreateListing != nil {
		return mmCreateListing.funcCreateListing(ctx, authorID, title, description, imageURL, price)
	}
	mmCreateListing.t.Fatalf("Unexpected call to UseCaseMock.CreateListing. %v %v %v %v %v %v", ctx, authorID, title, description, imageURL, price)
	return
}

// CreateListingAfterCounter returns a count of finished UseCaseMock.CreateListing invocations
func (mmCreateListing *UseCaseMock) CreateListingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateListing.afterCreateListingCounter)
}

// CreateListingBeforeCounter returns a count of UseCaseMock.CreateListing invocations
func (mmCreateListing *UseCaseMock) CreateListingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateListing.beforeCreateListingCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.CreateListing.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateListing *mUseCaseMockCreateListing) Calls() []*UseCaseMockCreateListingParams {
	mmCreateListing.mutex.RLock()

	argCopy := make([]*UseCaseMockCreateListingParams, len(mmCreateListing.callArgs))
	copy(argCopy, mmCreateListing.callArgs)

	mmCreateListing.mutex.RUnlock()

	return argCopy
}

// MinimockCreateListingDone returns true if the count of the CreateListing invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockCreateListingDone() bool {
	if m.CreateListingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateListingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateListingMock.invocationsDone()
}

// MinimockCreateListingInspect logs each unmet expectation
func (m *UseCaseMock) MinimockCreateListingInspect() {
	for _, e := range m.CreateListingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.CreateListing at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateListingCounter := mm_atomic.LoadUint64(&m.afterCreateListingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateListingMock.defaultExpectation != nil && afterCreateListingCounter < 1 {
		if m.CreateListingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UseCaseMock.CreateListing at\n%s", m.CreateListingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UseCaseMock.CreateListing at\n%s with params: %#v", m.CreateListingMock.defaultExpectation.expectationOrigins.origin, *m.CreateListingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateListing != nil && afterCreateListingCounter < 1 {
		m.t.Errorf("Expected call to UseCaseMock.CreateListing at\n%s", m.funcCreateListingOrigin)
	}

	if !m.CreateListingMock.invocationsDone() && afterCreateListingCounter > 0 {
		m.t.Errorf("Expected %d calls to UseCaseMock.CreateListing at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateListingMock.expectedInvocations), m.CreateListingMock.expectedInvocationsOrigin, afterCreateListingCounter)
	}
}

type mUseCaseMockGetListings struct {
	optional           bool
	mock               *UseCaseMock
	defaultExpectation *UseCaseMockGetListingsExpectation
	expectations       []*UseCaseMockGetListingsExpectation

	callArgs []*UseCaseMockGetListingsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UseCaseMockGetListingsExpectation specifies expectation struct of the UseCase.GetListings
type UseCaseMockGetListingsExpectation struct {
	mock               *UseCaseMock
	params             *UseCaseMockGetListingsParams
	paramPtrs          *UseCaseMockGetListingsParamPtrs
	expectationOrigins UseCaseMockGetListingsExpectationOrigins
	results            *UseCaseMockGetListingsResults
	returnOrigin       string
	Counter            uint64
}

// UseCaseMockGetListingsParams contains parameters of the UseCase.GetListings
type UseCaseMockGetListingsParams struct {
	ctx      context.Context
	page     uint32
	perPage  uint32
	sortBy   string
	sortDesc bool
	minPrice *float32
	maxPrice *float32
}

// UseCaseMockGetListingsParamPtrs contains pointers to parameters of the UseCase.GetListings
type UseCaseMockGetListingsParamPtrs struct {
	ctx      *context.Context
	page     *uint32
	perPage  *uint32
	sortBy   *string
	sortDesc *bool
	minPrice **float32
	maxPrice **float32
}

// UseCaseMockGetListingsResults contains results of the UseCase.GetListings
type UseCaseMockGetListingsResults struct {
	lpa1 []*entity.Listing
	u1   uint32
	err  error
}

// UseCaseMockGetListingsOrigins contains origins of expectations of the UseCase.GetListings
type UseCaseMockGetListingsExpectationOrigins struct {
	origin         string
	originCtx      string
	originPage     string
	originPerPage  string
	originSortBy   string
	originSortDesc string
	originMinPrice string
	originMaxPrice string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetListings *mUseCaseMockGetListings) Optional() *mUseCaseMockGetListings {
	mmGetListings.optional = true
	return mmGetListings
}

// Expect sets up expected params for UseCase.GetListings
func (mmGetListings *mUseCaseMockGetListings) Expect(ctx context.Context, page uint32, perPage uint32, sortBy string, sortDesc bool, minPrice *float32, maxPrice *float32) *mUseCaseMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &UseCaseMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.paramPtrs != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by ExpectParams functions")
	}

	mmGetListings.defaultExpectation.params = &UseCaseMockGetListingsParams{ctx, page, perPage, sortBy, sortDesc, minPrice, maxPrice}
	mmGetListings.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetListings.expectations {
		if minimock.Equal(e.params, mmGetListings.defaultExpectation.params) {
			mmGetListings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListings.defaultExpectation.params)
		}
	}

	return mmGetListings
}

// ExpectCtxParam1 sets up expected param ctx for UseCase.GetListings
func (mmGetListings *mUseCaseMockGetListings) ExpectCtxParam1(ctx context.Context) *mUseCaseMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &UseCaseMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.params != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Expect")
	}

	if mmGetListings.defaultExpectation.paramPtrs == nil {
		mmGetListings.defaultExpectation.paramPtrs = &UseCaseMockGetListingsParamPtrs{}
	}
	mmGetListings.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetListings.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetListings
}

// ExpectPageParam2 sets up expected param page for UseCase.GetListings
func (mmGetListings *mUseCaseMockGetListings) ExpectPageParam2(page uint32) *mUseCaseMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &UseCaseMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.params != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Expect")
	}

	if mmGetListings.defaultExpectation.paramPtrs == nil {
		mmGetListings.defaultExpectation.paramPtrs = &UseCaseMockGetListingsParamPtrs{}
	}
	mmGetListings.defaultExpectation.paramPtrs.page = &page
	mmGetListings.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmGetListings
}

// ExpectPerPageParam3 sets up expected param perPage for UseCase.GetListings
func (mmGetListings *mUseCaseMockGetListings) ExpectPerPageParam3(perPage uint32) *mUseCaseMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &UseCaseMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.params != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Expect")
	}

	if mmGetListings.defaultExpectation.paramPtrs == nil {
		mmGetListings.defaultExpectation.paramPtrs = &UseCaseMockGetListingsParamPtrs{}
	}
	mmGetListings.defaultExpectation.paramPtrs.perPage = &perPage
	mmGetListings.defaultExpectation.expectationOrigins.originPerPage = minimock.CallerInfo(1)

	return mmGetListings
}

// ExpectSortByParam4 sets up expected param sortBy for UseCase.GetListings
func (mmGetListings *mUseCaseMockGetListings) ExpectSortByParam4(sortBy string) *mUseCaseMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &UseCaseMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.params != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Expect")
	}

	if mmGetListings.defaultExpectation.paramPtrs == nil {
		mmGetListings.defaultExpectation.paramPtrs = &UseCaseMockGetListingsParamPtrs{}
	}
	mmGetListings.defaultExpectation.paramPtrs.sortBy = &sortBy
	mmGetListings.defaultExpectation.expectationOrigins.originSortBy = minimock.CallerInfo(1)

	return mmGetListings
}

// ExpectSortDescParam5 sets up expected param sortDesc for UseCase.GetListings
func (mmGetListings *mUseCaseMockGetListings) ExpectSortDescParam5(sortDesc bool) *mUseCaseMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &UseCaseMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.params != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Expect")
	}

	if mmGetListings.defaultExpectation.paramPtrs == nil {
		mmGetListings.defaultExpectation.paramPtrs = &UseCaseMockGetListingsParamPtrs{}
	}
	mmGetListings.defaultExpectation.paramPtrs.sortDesc = &sortDesc
	mmGetListings.defaultExpectation.expectationOrigins.originSortDesc = minimock.CallerInfo(1)

	return mmGetListings
}

// ExpectMinPriceParam6 sets up expected param minPrice for UseCase.GetListings
func (mmGetListings *mUseCaseMockGetListings) ExpectMinPriceParam6(minPrice *float32) *mUseCaseMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &UseCaseMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.params != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Expect")
	}

	if mmGetListings.defaultExpectation.paramPtrs == nil {
		mmGetListings.defaultExpectation.paramPtrs = &UseCaseMockGetListingsParamPtrs{}
	}
	mmGetListings.defaultExpectation.paramPtrs.minPrice = &minPrice
	mmGetListings.defaultExpectation.expectationOrigins.originMinPrice = minimock.CallerInfo(1)

	return mmGetListings
}

// ExpectMaxPriceParam7 sets up expected param maxPrice for UseCase.GetListings
func (mmGetListings *mUseCaseMockGetListings) ExpectMaxPriceParam7(maxPrice *float32) *mUseCaseMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &UseCaseMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.params != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Expect")
	}

	if mmGetListings.defaultExpectation.paramPtrs == nil {
		mmGetListings.defaultExpectation.paramPtrs = &UseCaseMockGetListingsParamPtrs{}
	}
	mmGetListings.defaultExpectation.paramPtrs.maxPrice = &maxPrice
	mmGetListings.defaultExpectation.expectationOrigins.originMaxPrice = minimock.CallerInfo(1)

	return mmGetListings
}

// Inspect accepts an inspector function that has same arguments as the UseCase.GetListings
func (mmGetListings *mUseCaseMockGetListings) Inspect(f func(ctx context.Context, page uint32, perPage uint32, sortBy string, sortDesc bool, minPrice *float32, maxPrice *float32)) *mUseCaseMockGetListings {
	if mmGetListings.mock.inspectFuncGetListings != nil {
		mmGetListings.mock.t.Fatalf("Inspect function is already set for UseCaseMock.GetListings")
	}

	mmGetListings.mock.inspectFuncGetListings = f

	return mmGetListings
}

// Return sets up results that will be returned by UseCase.GetListings
func (mmGetListings *mUseCaseMockGetListings) Return(lpa1 []*entity.Listing, u1 uint32, err error) *UseCaseMock {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &UseCaseMockGetListingsExpectation{mock: mmGetListings.mock}
	}
	mmGetListings.defaultExpectation.results = &UseCaseMockGetListingsResults{lpa1, u1, err}
	mmGetListings.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetListings.mock
}

// Set uses given function f to mock the UseCase.GetListings method
func (mmGetListings *mUseCaseMockGetListings) Set(f func(ctx context.Context, page uint32, perPage uint32, sortBy string, sortDesc bool, minPrice *float32, maxPrice *float32) (lpa1 []*entity.Listing, u1 uint32, err error)) *UseCaseMock {
	if mmGetListings.defaultExpectation != nil {
		mmGetListings.mock.t.Fatalf("Default expectation is already set for the UseCase.GetListings method")
	}

	if len(mmGetListings.expectations) > 0 {
		mmGetListings.mock.t.Fatalf("Some expectations are already set for the UseCase.GetListings method")
	}

	mmGetListings.mock.funcGetListings = f
	mmGetListings.mock.funcGetListingsOrigin = minimock.CallerInfo(1)
	return mmGetListings.mock
}

// When sets expectation for the UseCase.GetListings which will trigger the result defined by the following
// Then helper
func (mmGetListings *mUseCaseMockGetListings) When(ctx context.Context, page uint32, perPage uint32, sortBy string, sortDesc bool, minPrice *float32, maxPrice *float32) *UseCaseMockGetListingsExpectation {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("UseCaseMock.GetListings mock is already set by Set")
	}

	expectation := &UseCaseMockGetListingsExpectation{
		mock:               mmGetListings.mock,
		params:             &UseCaseMockGetListingsParams{ctx, page, perPage, sortBy, sortDesc, minPrice, maxPrice},
		expectationOrigins: UseCaseMockGetListingsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetListings.expectations = append(mmGetListings.expectations, expectation)
	return expectation
}

// Then sets up UseCase.GetListings return parameters for the expectation previously defined by the When method
func (e *UseCaseMockGetListingsExpectation) Then(lpa1 []*entity.Listing, u1 uint32, err error) *UseCaseMock {
	e.results = &UseCaseMockGetListingsResults{lpa1, u1, err}
	return e.mock
}

// Times sets number of times UseCase.GetListings should be invoked
func (mmGetListings *mUseCaseMockGetListings) Times(n uint64) *mUseCaseMockGetListings {
	if n == 0 {
		mmGetListings.mock.t.Fatalf("Times of UseCaseMock.GetListings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetListings.expectedInvocations, n)
	mmGetListings.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetListings
}

func (mmGetListings *mUseCaseMockGetListings) invocationsDone() bool {
	if len(mmGetListings.expectations) == 0 && mmGetListings.defaultExpectation == nil && mmGetListings.mock.funcGetListings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetListings.mock.afterGetListingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetListings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetListings implements mm_listing.UseCase
func (mmGetListings *UseCaseMock) GetListings(ctx context.Context, page uint32, perPage uint32, sortBy string, sortDesc bool, minPrice *float32, maxPrice *float32) (lpa1 []*entity.Listing, u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetListings.beforeGetListingsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListings.afterGetListingsCounter, 1)

	mmGetListings.t.Helper()

	if mmGetListings.inspectFuncGetListings != nil {
		mmGetListings.inspectFuncGetListings(ctx, page, perPage, sortBy, sortDesc, minPrice, maxPrice)
	}

	mm_params := UseCaseMockGetListingsParams{ctx, page, perPage, sortBy, sortDesc, minPrice, maxPrice}

	// Record call args
	mmGetListings.GetListingsMock.mutex.Lock()
	mmGetListings.GetListingsMock.callArgs = append(mmGetListings.GetListingsMock.callArgs, &mm_params)
	mmGetListings.GetListingsMock.mutex.Unlock()

	for _, e := range mmGetListings.GetListingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lpa1, e.results.u1, e.results.err
		}
	}

	if mmGetListings.GetListingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListings.GetListingsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListings.GetListingsMock.defaultExpectation.params
		mm_want_ptrs := mmGetListings.GetListingsMock.defaultExpectation.paramPtrs

		mm_got := UseCaseMockGetListingsParams{ctx, page, perPage, sortBy, sortDesc, minPrice, maxPrice}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetListings.t.Errorf("UseCaseMock.GetListings got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmGetListings.t.Errorf("UseCaseMock.GetListings got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.perPage != nil && !minimock.Equal(*mm_want_ptrs.perPage, mm_got.perPage) {
				mmGetListings.t.Errorf("UseCaseMock.GetListings got unexpected parameter perPage, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.originPerPage, *mm_want_ptrs.perPage, mm_got.perPage, minimock.Diff(*mm_want_ptrs.perPage, mm_got.perPage))
			}

			if mm_want_ptrs.sortBy != nil && !minimock.Equal(*mm_want_ptrs.sortBy, mm_got.sortBy) {
				mmGetListings.t.Errorf("UseCaseMock.GetListings got unexpected parameter sortBy, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.originSortBy, *mm_want_ptrs.sortBy, mm_got.sortBy, minimock.Diff(*mm_want_ptrs.sortBy, mm_got.sortBy))
			}

			if mm_want_ptrs.sortDesc != nil && !minimock.Equal(*mm_want_ptrs.sortDesc, mm_got.sortDesc) {
				mmGetListings.t.Errorf("UseCaseMock.GetListings got unexpected parameter sortDesc, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.originSortDesc, *mm_want_ptrs.sortDesc, mm_got.sortDesc, minimock.Diff(*mm_want_ptrs.sortDesc, mm_got.sortDesc))
			}

			if mm_want_ptrs.minPrice != nil && !minimock.Equal(*mm_want_ptrs.minPrice, mm_got.minPrice) {
				mmGetListings.t.Errorf("UseCaseMock.GetListings got unexpected parameter minPrice, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.originMinPrice, *mm_want_ptrs.minPrice, mm_got.minPrice, minimock.Diff(*mm_want_ptrs.minPrice, mm_got.minPrice))
			}

			if mm_want_ptrs.maxPrice != nil && !minimock.Equal(*mm_want_ptrs.maxPrice, mm_got.maxPrice) {
				mmGetListings.t.Errorf("UseCaseMock.GetListings got unexpected parameter maxPrice, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.originMaxPrice, *mm_want_ptrs.maxPrice, mm_got.maxPrice, minimock.Diff(*mm_want_ptrs.maxPrice, mm_got.maxPrice))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListings.t.Errorf("UseCaseMock.GetListings got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListings.GetListingsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListings.t.Fatal("No results are set for the UseCaseMock.GetListings")
		}
		return (*mm_results).lpa1, (*mm_results).u1, (*mm_results).err
	}
	if mmGetListings.funcGetListings != nil {
		return mmGetListings.funcGetListings(ctx, page, perPage, sortBy, sortDesc, minPrice, maxPrice)
	}
	mmGetListings.t.Fatalf("Unexpected call to UseCaseMock.GetListings. %v %v %v %v %v %v %v", ctx, page, perPage, sortBy, sortDesc, minPrice, maxPrice)
	return
}

// GetListingsAfterCounter returns a count of finished UseCaseMock.GetListings invocations
func (mmGetListings *UseCaseMock) GetListingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListings.afterGetListingsCounter)
}

// GetListingsBeforeCounter returns a count of UseCaseMock.GetListings invocations
func (mmGetListings *UseCaseMock) GetListingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListings.beforeGetListingsCounter)
}

// Calls returns a list of arguments used in each call to UseCaseMock.GetListings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListings *mUseCaseMockGetListings) Calls() []*UseCaseMockGetListingsParams {
	mmGetListings.mutex.RLock()

	argCopy := make([]*UseCaseMockGetListingsParams, len(mmGetListings.callArgs))
	copy(argCopy, mmGetListings.callArgs)

	mmGetListings.mutex.RUnlock()

	return argCopy
}

// MinimockGetListingsDone returns true if the count of the GetListings invocations corresponds
// the number of defined expectations
func (m *UseCaseMock) MinimockGetListingsDone() bool {
	if m.GetListingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetListingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetListingsMock.invocationsDone()
}

// MinimockGetListingsInspect logs each unmet expectation
func (m *UseCaseMock) MinimockGetListingsInspect() {
	for _, e := range m.GetListingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UseCaseMock.GetListings at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetListingsCounter := mm_atomic.LoadUint64(&m.afterGetListingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetListingsMock.defaultExpectation != nil && afterGetListingsCounter < 1 {
		if m.GetListingsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UseCaseMock.GetListings at\n%s", m.GetListingsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UseCaseMock.GetListings at\n%s with params: %#v", m.GetListingsMock.defaultExpectation.expectationOrigins.origin, *m.GetListingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListings != nil && afterGetListingsCounter < 1 {
		m.t.Errorf("Expected call to UseCaseMock.GetListings at\n%s", m.funcGetListingsOrigin)
	}

	if !m.GetListingsMock.invocationsDone() && afterGetListingsCounter > 0 {
		m.t.Errorf("Expected %d calls to UseCaseMock.GetListings at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetListingsMock.expectedInvocations), m.GetListingsMock.expectedInvocationsOrigin, afterGetListingsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UseCaseMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateListingInspect()

			m.MinimockGetListingsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UseCaseMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UseCaseMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateListingDone() &&
		m.MinimockGetListingsDone()
}
