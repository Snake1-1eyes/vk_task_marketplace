// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Snake1-1eyes/vk_task_marketplace/internal/listing.Repository -o repository_mock.go -n RepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Snake1-1eyes/vk_task_marketplace/internal/entity"
	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements mm_listing.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateListing          func(ctx context.Context, listing *entity.Listing) (lp1 *entity.Listing, err error)
	funcCreateListingOrigin    string
	inspectFuncCreateListing   func(ctx context.Context, listing *entity.Listing)
	afterCreateListingCounter  uint64
	beforeCreateListingCounter uint64
	CreateListingMock          mRepositoryMockCreateListing

	funcGetListings          func(ctx context.Context, filter *entity.ListingFilter) (lpa1 []*entity.Listing, u1 uint32, err error)
	funcGetListingsOrigin    string
	inspectFuncGetListings   func(ctx context.Context, filter *entity.ListingFilter)
	afterGetListingsCounter  uint64
	beforeGetListingsCounter uint64
	GetListingsMock          mRepositoryMockGetListings
}

// NewRepositoryMock returns a mock for mm_listing.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateListingMock = mRepositoryMockCreateListing{mock: m}
	m.CreateListingMock.callArgs = []*RepositoryMockCreateListingParams{}

	m.GetListingsMock = mRepositoryMockGetListings{mock: m}
	m.GetListingsMock.callArgs = []*RepositoryMockGetListingsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockCreateListing struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateListingExpectation
	expectations       []*RepositoryMockCreateListingExpectation

	callArgs []*RepositoryMockCreateListingParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCreateListingExpectation specifies expectation struct of the Repository.CreateListing
type RepositoryMockCreateListingExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCreateListingParams
	paramPtrs          *RepositoryMockCreateListingParamPtrs
	expectationOrigins RepositoryMockCreateListingExpectationOrigins
	results            *RepositoryMockCreateListingResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCreateListingParams contains parameters of the Repository.CreateListing
type RepositoryMockCreateListingParams struct {
	ctx     context.Context
	listing *entity.Listing
}

// RepositoryMockCreateListingParamPtrs contains pointers to parameters of the Repository.CreateListing
type RepositoryMockCreateListingParamPtrs struct {
	ctx     *context.Context
	listing **entity.Listing
}

// RepositoryMockCreateListingResults contains results of the Repository.CreateListing
type RepositoryMockCreateListingResults struct {
	lp1 *entity.Listing
	err error
}

// RepositoryMockCreateListingOrigins contains origins of expectations of the Repository.CreateListing
type RepositoryMockCreateListingExpectationOrigins struct {
	origin        string
	originCtx     string
	originListing string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateListing *mRepositoryMockCreateListing) Optional() *mRepositoryMockCreateListing {
	mmCreateListing.optional = true
	return mmCreateListing
}

// Expect sets up expected params for Repository.CreateListing
func (mmCreateListing *mRepositoryMockCreateListing) Expect(ctx context.Context, listing *entity.Listing) *mRepositoryMockCreateListing {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("RepositoryMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &RepositoryMockCreateListingExpectation{}
	}

	if mmCreateListing.defaultExpectation.paramPtrs != nil {
		mmCreateListing.mock.t.Fatalf("RepositoryMock.CreateListing mock is already set by ExpectParams functions")
	}

	mmCreateListing.defaultExpectation.params = &RepositoryMockCreateListingParams{ctx, listing}
	mmCreateListing.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateListing.expectations {
		if minimock.Equal(e.params, mmCreateListing.defaultExpectation.params) {
			mmCreateListing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateListing.defaultExpectation.params)
		}
	}

	return mmCreateListing
}

// ExpectCtxParam1 sets up expected param ctx for Repository.CreateListing
func (mmCreateListing *mRepositoryMockCreateListing) ExpectCtxParam1(ctx context.Context) *mRepositoryMockCreateListing {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("RepositoryMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &RepositoryMockCreateListingExpectation{}
	}

	if mmCreateListing.defaultExpectation.params != nil {
		mmCreateListing.mock.t.Fatalf("RepositoryMock.CreateListing mock is already set by Expect")
	}

	if mmCreateListing.defaultExpectation.paramPtrs == nil {
		mmCreateListing.defaultExpectation.paramPtrs = &RepositoryMockCreateListingParamPtrs{}
	}
	mmCreateListing.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateListing.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateListing
}

// ExpectListingParam2 sets up expected param listing for Repository.CreateListing
func (mmCreateListing *mRepositoryMockCreateListing) ExpectListingParam2(listing *entity.Listing) *mRepositoryMockCreateListing {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("RepositoryMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &RepositoryMockCreateListingExpectation{}
	}

	if mmCreateListing.defaultExpectation.params != nil {
		mmCreateListing.mock.t.Fatalf("RepositoryMock.CreateListing mock is already set by Expect")
	}

	if mmCreateListing.defaultExpectation.paramPtrs == nil {
		mmCreateListing.defaultExpectation.paramPtrs = &RepositoryMockCreateListingParamPtrs{}
	}
	mmCreateListing.defaultExpectation.paramPtrs.listing = &listing
	mmCreateListing.defaultExpectation.expectationOrigins.originListing = minimock.CallerInfo(1)

	return mmCreateListing
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateListing
func (mmCreateListing *mRepositoryMockCreateListing) Inspect(f func(ctx context.Context, listing *entity.Listing)) *mRepositoryMockCreateListing {
	if mmCreateListing.mock.inspectFuncCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateListing")
	}

	mmCreateListing.mock.inspectFuncCreateListing = f

	return mmCreateListing
}

// Return sets up results that will be returned by Repository.CreateListing
func (mmCreateListing *mRepositoryMockCreateListing) Return(lp1 *entity.Listing, err error) *RepositoryMock {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("RepositoryMock.CreateListing mock is already set by Set")
	}

	if mmCreateListing.defaultExpectation == nil {
		mmCreateListing.defaultExpectation = &RepositoryMockCreateListingExpectation{mock: mmCreateListing.mock}
	}
	mmCreateListing.defaultExpectation.results = &RepositoryMockCreateListingResults{lp1, err}
	mmCreateListing.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateListing.mock
}

// Set uses given function f to mock the Repository.CreateListing method
func (mmCreateListing *mRepositoryMockCreateListing) Set(f func(ctx context.Context, listing *entity.Listing) (lp1 *entity.Listing, err error)) *RepositoryMock {
	if mmCreateListing.defaultExpectation != nil {
		mmCreateListing.mock.t.Fatalf("Default expectation is already set for the Repository.CreateListing method")
	}

	if len(mmCreateListing.expectations) > 0 {
		mmCreateListing.mock.t.Fatalf("Some expectations are already set for the Repository.CreateListing method")
	}

	mmCreateListing.mock.funcCreateListing = f
	mmCreateListing.mock.funcCreateListingOrigin = minimock.CallerInfo(1)
	return mmCreateListing.mock
}

// When sets expectation for the Repository.CreateListing which will trigger the result defined by the following
// Then helper
func (mmCreateListing *mRepositoryMockCreateListing) When(ctx context.Context, listing *entity.Listing) *RepositoryMockCreateListingExpectation {
	if mmCreateListing.mock.funcCreateListing != nil {
		mmCreateListing.mock.t.Fatalf("RepositoryMock.CreateListing mock is already set by Set")
	}

	expectation := &RepositoryMockCreateListingExpectation{
		mock:               mmCreateListing.mock,
		params:             &RepositoryMockCreateListingParams{ctx, listing},
		expectationOrigins: RepositoryMockCreateListingExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateListing.expectations = append(mmCreateListing.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateListing return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateListingExpectation) Then(lp1 *entity.Listing, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateListingResults{lp1, err}
	return e.mock
}

// Times sets number of times Repository.CreateListing should be invoked
func (mmCreateListing *mRepositoryMockCreateListing) Times(n uint64) *mRepositoryMockCreateListing {
	if n == 0 {
		mmCreateListing.mock.t.Fatalf("Times of RepositoryMock.CreateListing mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateListing.expectedInvocations, n)
	mmCreateListing.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateListing
}

func (mmCreateListing *mRepositoryMockCreateListing) invocationsDone() bool {
	if len(mmCreateListing.expectations) == 0 && mmCreateListing.defaultExpectation == nil && mmCreateListing.mock.funcCreateListing == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateListing.mock.afterCreateListingCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateListing.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateListing implements mm_listing.Repository
func (mmCreateListing *RepositoryMock) CreateListing(ctx context.Context, listing *entity.Listing) (lp1 *entity.Listing, err error) {
	mm_atomic.AddUint64(&mmCreateListing.beforeCreateListingCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateListing.afterCreateListingCounter, 1)

	mmCreateListing.t.Helper()

	if mmCreateListing.inspectFuncCreateListing != nil {
		mmCreateListing.inspectFuncCreateListing(ctx, listing)
	}

	mm_params := RepositoryMockCreateListingParams{ctx, listing}

	// Record call args
	mmCreateListing.CreateListingMock.mutex.Lock()
	mmCreateListing.CreateListingMock.callArgs = append(mmCreateListing.CreateListingMock.callArgs, &mm_params)
	mmCreateListing.CreateListingMock.mutex.Unlock()

	for _, e := range mmCreateListing.CreateListingMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmCreateListing.CreateListingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateListing.CreateListingMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateListing.CreateListingMock.defaultExpectation.params
		mm_want_ptrs := mmCreateListing.CreateListingMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCreateListingParams{ctx, listing}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateListing.t.Errorf("RepositoryMock.CreateListing got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateListing.CreateListingMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.listing != nil && !minimock.Equal(*mm_want_ptrs.listing, mm_got.listing) {
				mmCreateListing.t.Errorf("RepositoryMock.CreateListing got unexpected parameter listing, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateListing.CreateListingMock.defaultExpectation.expectationOrigins.originListing, *mm_want_ptrs.listing, mm_got.listing, minimock.Diff(*mm_want_ptrs.listing, mm_got.listing))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateListing.t.Errorf("RepositoryMock.CreateListing got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateListing.CreateListingMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateListing.CreateListingMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateListing.t.Fatal("No results are set for the RepositoryMock.CreateListing")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmCreateListing.funcCreateListing != nil {
		return mmCreateListing.funcCreateListing(ctx, listing)
	}
	mmCreateListing.t.Fatalf("Unexpected call to RepositoryMock.CreateListing. %v %v", ctx, listing)
	return
}

// CreateListingAfterCounter returns a count of finished RepositoryMock.CreateListing invocations
func (mmCreateListing *RepositoryMock) CreateListingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateListing.afterCreateListingCounter)
}

// CreateListingBeforeCounter returns a count of RepositoryMock.CreateListing invocations
func (mmCreateListing *RepositoryMock) CreateListingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateListing.beforeCreateListingCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateListing.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateListing *mRepositoryMockCreateListing) Calls() []*RepositoryMockCreateListingParams {
	mmCreateListing.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateListingParams, len(mmCreateListing.callArgs))
	copy(argCopy, mmCreateListing.callArgs)

	mmCreateListing.mutex.RUnlock()

	return argCopy
}

// MinimockCreateListingDone returns true if the count of the CreateListing invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateListingDone() bool {
	if m.CreateListingMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateListingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateListingMock.invocationsDone()
}

// MinimockCreateListingInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateListingInspect() {
	for _, e := range m.CreateListingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateListing at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateListingCounter := mm_atomic.LoadUint64(&m.afterCreateListingCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateListingMock.defaultExpectation != nil && afterCreateListingCounter < 1 {
		if m.CreateListingMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.CreateListing at\n%s", m.CreateListingMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateListing at\n%s with params: %#v", m.CreateListingMock.defaultExpectation.expectationOrigins.origin, *m.CreateListingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateListing != nil && afterCreateListingCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.CreateListing at\n%s", m.funcCreateListingOrigin)
	}

	if !m.CreateListingMock.invocationsDone() && afterCreateListingCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.CreateListing at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateListingMock.expectedInvocations), m.CreateListingMock.expectedInvocationsOrigin, afterCreateListingCounter)
	}
}

type mRepositoryMockGetListings struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetListingsExpectation
	expectations       []*RepositoryMockGetListingsExpectation

	callArgs []*RepositoryMockGetListingsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetListingsExpectation specifies expectation struct of the Repository.GetListings
type RepositoryMockGetListingsExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetListingsParams
	paramPtrs          *RepositoryMockGetListingsParamPtrs
	expectationOrigins RepositoryMockGetListingsExpectationOrigins
	results            *RepositoryMockGetListingsResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetListingsParams contains parameters of the Repository.GetListings
type RepositoryMockGetListingsParams struct {
	ctx    context.Context
	filter *entity.ListingFilter
}

// RepositoryMockGetListingsParamPtrs contains pointers to parameters of the Repository.GetListings
type RepositoryMockGetListingsParamPtrs struct {
	ctx    *context.Context
	filter **entity.ListingFilter
}

// RepositoryMockGetListingsResults contains results of the Repository.GetListings
type RepositoryMockGetListingsResults struct {
	lpa1 []*entity.Listing
	u1   uint32
	err  error
}

// RepositoryMockGetListingsOrigins contains origins of expectations of the Repository.GetListings
type RepositoryMockGetListingsExpectationOrigins struct {
	origin       string
	originCtx    string
	originFilter string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetListings *mRepositoryMockGetListings) Optional() *mRepositoryMockGetListings {
	mmGetListings.optional = true
	return mmGetListings
}

// Expect sets up expected params for Repository.GetListings
func (mmGetListings *mRepositoryMockGetListings) Expect(ctx context.Context, filter *entity.ListingFilter) *mRepositoryMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("RepositoryMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &RepositoryMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.paramPtrs != nil {
		mmGetListings.mock.t.Fatalf("RepositoryMock.GetListings mock is already set by ExpectParams functions")
	}

	mmGetListings.defaultExpectation.params = &RepositoryMockGetListingsParams{ctx, filter}
	mmGetListings.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetListings.expectations {
		if minimock.Equal(e.params, mmGetListings.defaultExpectation.params) {
			mmGetListings.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListings.defaultExpectation.params)
		}
	}

	return mmGetListings
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetListings
func (mmGetListings *mRepositoryMockGetListings) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("RepositoryMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &RepositoryMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.params != nil {
		mmGetListings.mock.t.Fatalf("RepositoryMock.GetListings mock is already set by Expect")
	}

	if mmGetListings.defaultExpectation.paramPtrs == nil {
		mmGetListings.defaultExpectation.paramPtrs = &RepositoryMockGetListingsParamPtrs{}
	}
	mmGetListings.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetListings.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetListings
}

// ExpectFilterParam2 sets up expected param filter for Repository.GetListings
func (mmGetListings *mRepositoryMockGetListings) ExpectFilterParam2(filter *entity.ListingFilter) *mRepositoryMockGetListings {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("RepositoryMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &RepositoryMockGetListingsExpectation{}
	}

	if mmGetListings.defaultExpectation.params != nil {
		mmGetListings.mock.t.Fatalf("RepositoryMock.GetListings mock is already set by Expect")
	}

	if mmGetListings.defaultExpectation.paramPtrs == nil {
		mmGetListings.defaultExpectation.paramPtrs = &RepositoryMockGetListingsParamPtrs{}
	}
	mmGetListings.defaultExpectation.paramPtrs.filter = &filter
	mmGetListings.defaultExpectation.expectationOrigins.originFilter = minimock.CallerInfo(1)

	return mmGetListings
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetListings
func (mmGetListings *mRepositoryMockGetListings) Inspect(f func(ctx context.Context, filter *entity.ListingFilter)) *mRepositoryMockGetListings {
	if mmGetListings.mock.inspectFuncGetListings != nil {
		mmGetListings.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetListings")
	}

	mmGetListings.mock.inspectFuncGetListings = f

	return mmGetListings
}

// Return sets up results that will be returned by Repository.GetListings
func (mmGetListings *mRepositoryMockGetListings) Return(lpa1 []*entity.Listing, u1 uint32, err error) *RepositoryMock {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("RepositoryMock.GetListings mock is already set by Set")
	}

	if mmGetListings.defaultExpectation == nil {
		mmGetListings.defaultExpectation = &RepositoryMockGetListingsExpectation{mock: mmGetListings.mock}
	}
	mmGetListings.defaultExpectation.results = &RepositoryMockGetListingsResults{lpa1, u1, err}
	mmGetListings.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetListings.mock
}

// Set uses given function f to mock the Repository.GetListings method
func (mmGetListings *mRepositoryMockGetListings) Set(f func(ctx context.Context, filter *entity.ListingFilter) (lpa1 []*entity.Listing, u1 uint32, err error)) *RepositoryMock {
	if mmGetListings.defaultExpectation != nil {
		mmGetListings.mock.t.Fatalf("Default expectation is already set for the Repository.GetListings method")
	}

	if len(mmGetListings.expectations) > 0 {
		mmGetListings.mock.t.Fatalf("Some expectations are already set for the Repository.GetListings method")
	}

	mmGetListings.mock.funcGetListings = f
	mmGetListings.mock.funcGetListingsOrigin = minimock.CallerInfo(1)
	return mmGetListings.mock
}

// When sets expectation for the Repository.GetListings which will trigger the result defined by the following
// Then helper
func (mmGetListings *mRepositoryMockGetListings) When(ctx context.Context, filter *entity.ListingFilter) *RepositoryMockGetListingsExpectation {
	if mmGetListings.mock.funcGetListings != nil {
		mmGetListings.mock.t.Fatalf("RepositoryMock.GetListings mock is already set by Set")
	}

	expectation := &RepositoryMockGetListingsExpectation{
		mock:               mmGetListings.mock,
		params:             &RepositoryMockGetListingsParams{ctx, filter},
		expectationOrigins: RepositoryMockGetListingsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetListings.expectations = append(mmGetListings.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetListings return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetListingsExpectation) Then(lpa1 []*entity.Listing, u1 uint32, err error) *RepositoryMock {
	e.results = &RepositoryMockGetListingsResults{lpa1, u1, err}
	return e.mock
}

// Times sets number of times Repository.GetListings should be invoked
func (mmGetListings *mRepositoryMockGetListings) Times(n uint64) *mRepositoryMockGetListings {
	if n == 0 {
		mmGetListings.mock.t.Fatalf("Times of RepositoryMock.GetListings mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetListings.expectedInvocations, n)
	mmGetListings.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetListings
}

func (mmGetListings *mRepositoryMockGetListings) invocationsDone() bool {
	if len(mmGetListings.expectations) == 0 && mmGetListings.defaultExpectation == nil && mmGetListings.mock.funcGetListings == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetListings.mock.afterGetListingsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetListings.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetListings implements mm_listing.Repository
func (mmGetListings *RepositoryMock) GetListings(ctx context.Context, filter *entity.ListingFilter) (lpa1 []*entity.Listing, u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetListings.beforeGetListingsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListings.afterGetListingsCounter, 1)

	mmGetListings.t.Helper()

	if mmGetListings.inspectFuncGetListings != nil {
		mmGetListings.inspectFuncGetListings(ctx, filter)
	}

	mm_params := RepositoryMockGetListingsParams{ctx, filter}

	// Record call args
	mmGetListings.GetListingsMock.mutex.Lock()
	mmGetListings.GetListingsMock.callArgs = append(mmGetListings.GetListingsMock.callArgs, &mm_params)
	mmGetListings.GetListingsMock.mutex.Unlock()

	for _, e := range mmGetListings.GetListingsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lpa1, e.results.u1, e.results.err
		}
	}

	if mmGetListings.GetListingsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListings.GetListingsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListings.GetListingsMock.defaultExpectation.params
		mm_want_ptrs := mmGetListings.GetListingsMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetListingsParams{ctx, filter}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetListings.t.Errorf("RepositoryMock.GetListings got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.filter != nil && !minimock.Equal(*mm_want_ptrs.filter, mm_got.filter) {
				mmGetListings.t.Errorf("RepositoryMock.GetListings got unexpected parameter filter, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.originFilter, *mm_want_ptrs.filter, mm_got.filter, minimock.Diff(*mm_want_ptrs.filter, mm_got.filter))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListings.t.Errorf("RepositoryMock.GetListings got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetListings.GetListingsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListings.GetListingsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListings.t.Fatal("No results are set for the RepositoryMock.GetListings")
		}
		return (*mm_results).lpa1, (*mm_results).u1, (*mm_results).err
	}
	if mmGetListings.funcGetListings != nil {
		return mmGetListings.funcGetListings(ctx, filter)
	}
	mmGetListings.t.Fatalf("Unexpected call to RepositoryMock.GetListings. %v %v", ctx, filter)
	return
}

// GetListingsAfterCounter returns a count of finished RepositoryMock.GetListings invocations
func (mmGetListings *RepositoryMock) GetListingsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListings.afterGetListingsCounter)
}

// GetListingsBeforeCounter returns a count of RepositoryMock.GetListings invocations
func (mmGetListings *RepositoryMock) GetListingsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListings.beforeGetListingsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetListings.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListings *mRepositoryMockGetListings) Calls() []*RepositoryMockGetListingsParams {
	mmGetListings.mutex.RLock()

	argCopy := make([]*RepositoryMockGetListingsParams, len(mmGetListings.callArgs))
	copy(argCopy, mmGetListings.callArgs)

	mmGetListings.mutex.RUnlock()

	return argCopy
}

// MinimockGetListingsDone returns true if the count of the GetListings invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetListingsDone() bool {
	if m.GetListingsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetListingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetListingsMock.invocationsDone()
}

// MinimockGetListingsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetListingsInspect() {
	for _, e := range m.GetListingsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetListings at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetListingsCounter := mm_atomic.LoadUint64(&m.afterGetListingsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetListingsMock.defaultExpectation != nil && afterGetListingsCounter < 1 {
		if m.GetListingsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetListings at\n%s", m.GetListingsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetListings at\n%s with params: %#v", m.GetListingsMock.defaultExpectation.expectationOrigins.origin, *m.GetListingsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListings != nil && afterGetListingsCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetListings at\n%s", m.funcGetListingsOrigin)
	}

	if !m.GetListingsMock.invocationsDone() && afterGetListingsCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetListings at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetListingsMock.expectedInvocations), m.GetListingsMock.expectedInvocationsOrigin, afterGetListingsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateListingInspect()

			m.MinimockGetListingsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateListingDone() &&
		m.MinimockGetListingsDone()
}
